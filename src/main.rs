extern crate cc;

use std::collections::HashMap;
use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use std::process::Command;
use which::which;

struct NoFileYet;
struct WithEclairFile(String);

struct Build<T = NoFileYet> {
    // TODO use str?
    clang_compiler: String,
    eclair_compiler: String,
    datalog_dir: Option<String>, // TODO remove once Eclair is fully self-hosted
    eclair_file: T,
}

impl Build<NoFileYet> {
    pub fn new() -> Self {
        Build {
            clang_compiler: "clang".to_string(),
            eclair_compiler: "eclair".to_string(),
            eclair_file: NoFileYet,
            datalog_dir: None,
        }
    }

    // NOTE: Only one file allowed for now.
    pub fn file(self, path: impl Into<String>) -> Build<WithEclairFile> {
        Build {
            clang_compiler: self.clang_compiler,
            eclair_compiler: self.eclair_compiler,
            datalog_dir: self.datalog_dir,
            eclair_file: WithEclairFile(path.into()),
        }
    }
}

impl<T> Build<T> {
    pub fn eclair(mut self, path: impl Into<String>) -> Self {
        self.eclair_compiler = path.into();
        self
    }

    // NOTE: for now we only allow clang since that is supported by cc crate.
    // Technically just llc could also work.
    pub fn clang(mut self, path: impl Into<String>) -> Self {
        self.clang_compiler = path.into();
        self
    }

    pub fn datalog_dir(mut self, path: impl Into<String>) -> Self {
        self.datalog_dir = path.into().into();
        self
    }
}

impl Build<WithEclairFile> {
    pub fn compile(self) {
        self.check_valid_setup();
        let llvm_output_file = self.eclair_compile();
        self.llvm_compile(llvm_output_file);
    }

    fn check_valid_setup(&self) {
        let _ = which(&self.eclair_compiler).expect("Could not locate eclair compiler!");
        let _ = which(&self.clang_compiler).expect("Could not locate clang compiler!");
    }

    fn eclair_compile(&self) -> std::path::PathBuf {
        let output = self.llvm_output_file();

        let mut env = HashMap::new();
        if let Some(dl_dir) = &self.datalog_dir {
            env.insert("DATALOG_DIR", dl_dir);
        }

        let llvm_ir = Command::new(&self.eclair_compiler)
            .args(["compile", &self.eclair_file.0, "--emit", "llvm"])
            .envs(env)
            .output()
            .unwrap();

        let mut f = File::create(&output).unwrap();
        f.write_all(llvm_ir.stdout.as_slice())
            .expect("Failed to write LLVM IR generated by Eclair to file");

        output
    }

    fn llvm_compile(self, llvm_file: std::path::PathBuf) {
        // TODO allow specifying another library name, right now libeclair.a is forced because of
        // how eclair_bindings crate works
        let lib_name = "eclair";
        cc::Build::new()
            .compiler(self.clang_compiler)
            .file(llvm_file)
            .compile(lib_name);
    }

    fn llvm_output_file(&self) -> std::path::PathBuf {
        let out_dir = env::var("OUT_DIR").unwrap();
        Path::new(&out_dir).join("program.ll")
    }
}

// TODO convert to library, remove main
fn main() {
    Build::new()
        .eclair("/path/to/eclair")
        .datalog_dir("/path/to/datalog_dir")
        .clang("clang-14")
        .file("/path/to/test.eclair")
        .compile();
}
